--- matrix.py.orig
+++ matrix.py
@@ -4,39 +4,53 @@
 # gwidion@gmail.com
 # GPL. v3.0
 
-MAX_CASCADES = 400
+MAX_CASCADES = 600
+MAX_COLS = 20
+FRAME_DELAY = 0.02
 
-import os, sys, time
-from random import randrange, choice
+MAX_SPEED  = 5
 
-sh = os.system
-pr = lambda text: print(text, end="")
-esqs = "\x1b["
+import shutil, sys, time
+from random import choice, randrange, paretovariate
+
+CSI = "\x1b["
+pr = lambda command: print("\x1b[", command, sep="", end="")
 getchars = lambda start, end: [chr(i) for i in range(start, end)]
 
 black, green, white = "30", "32", "37"
 
-latin = getchars(0x30, 0x7e)
-greek = getchars(0x390, 0x3cf)
-hebrew = getchars(0x590, 0x5FF)
-
-chars= latin + greek # + hebrew
+latinupper = getchars(0x41, 0x5A)
+latinlower = getchars(0x61, 0x7A)
+katakana = getchars(0xFF66, 0xFF9D)
+
+#greek = getchars(0x390, 0x3d0)
+#hebrew = getchars(0x5d0, 0x5eb)
+#cyrillic = getchars(0x400, 0x50)
+
+#chars= latin + greek + hebrew + cyrillic
+chars= latinupper + latinlower + katakana
+
+def pareto(limit):
+    scale = lines // 2
+    number = (paretovariate(1.16) - 1) * scale
+    return max(0, limit - number)
 
 def init():
     global cols, lines
-    sh("setterm -cursor off")
-    cols = int(os.popen("tput cols").read())
-    lines = int(os.popen("tput lines").read())
+    cols, lines = shutil.get_terminal_size()
+    pr("?25l")  # Hides cursor
+    pr("s")  # Saves cursor position
 
 def end():
-    pr(esqs + "m")
-    sh("clear")
-    sh("setterm -cursor on")
+    pr("m")   # reset attributes
+    pr("2J")  # clear screen
+    pr("u")  # Restores cursor position
+    pr("?25h")  # Show cursor
 
 def print_at(char, x, y, color="", bright="0"):
-    pr("%s%d;%df" %(esqs, y, x))
-    pr(esqs + bright + ";" + color + "m")
-    pr(char)
+    pr("%d;%df" % (y, x))
+    pr(bright + ";" + color + "m")
+    print(char, end="", flush=True)
 
 def update_line(speed, counter, line):
     counter += 1
@@ -46,13 +60,13 @@
     return counter, line
 
 def cascade(col):
-    speed = randrange(0, 4) + 1
-    espeed = randrange(0, 4) + 1
+    speed = randrange(1, MAX_SPEED)
+    espeed = randrange(1, MAX_SPEED)
     line = counter = ecounter = 0
     oldline = eline = -1
     erasing = False
     bright = "1"
-    limit = lines - randrange(lines)
+    limit = pareto(lines)
     while True:
         counter, line = update_line(speed , counter, line)
         if randrange(10 * speed) < 1:
@@ -81,13 +95,13 @@
         stopped = iterate(cascading)
         sys.stdout.flush()
         cascading.difference_update(stopped)
-        time.sleep(.06)
+        time.sleep(FRAME_DELAY)
 
 def add_new(cascading):
-    if randrange(MAX_CASCADES) > len(cascading):
+    if randrange(MAX_CASCADES + 1) > len(cascading):
         col = randrange(cols)
-        for i in range(randrange(1, 20)):
-            cascading.add(cascade((col + i - 1) % cols))
+        for i in range(randrange(MAX_COLS)):
+            cascading.add(cascade((col + i) % cols))
         return True
     return False
 
